{"meta":{"title":"Zyh's site","subtitle":"这里是Zyh的博客","description":null,"author":"Zyh","url":"http://sduzhang.cn","root":"/"},"pages":[{"title":"关于","date":"2019-07-27T02:36:02.000Z","updated":"2019-07-29T01:31:57.803Z","comments":true,"path":"about/index.html","permalink":"http://sduzhang.cn/about/index.html","excerpt":"","text":"Welcome经过一天的折腾终于有了一个自己的博客 工具是 hexo + github page 一日速成主要是靠这个博客 这个博客是用来记录我的学习过程中和自己对一些事情的见解，感兴趣的话可以关注我或者联系我。"},{"title":"categories","date":"2019-07-27T02:32:40.000Z","updated":"2019-07-27T02:34:17.890Z","comments":false,"path":"categories/index.html","permalink":"http://sduzhang.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-27T02:34:42.000Z","updated":"2019-07-27T02:35:25.214Z","comments":false,"path":"tags/index.html","permalink":"http://sduzhang.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ubuntu修改登录界面壁纸","slug":"ubuntu修改登录壁纸","date":"2019-12-03T04:02:52.000Z","updated":"2019-12-03T04:18:42.567Z","comments":true,"path":"2019/12/03/ubuntu修改登录壁纸/","link":"","permalink":"http://sduzhang.cn/2019/12/03/ubuntu修改登录壁纸/","excerpt":"","text":"由于ubuntu更新的时候有时候会修改gnome的配置文件，这种情况下就需要重新设置锁屏壁纸，由于偶尔会用到所以在这里记录一下方法。 首先执行命令： 1sudo gedit /etc/alternatives/gdm3.css 然后修改lockDialogGroup块： 12345#lockDialogGroup &#123; background: #2c001e url(file:///usr/share/backgrounds/rime_sea.png); background-repeat: no-repeat; background-size: cover; background-posion: center; &#125;","categories":[{"name":"工具包","slug":"工具包","permalink":"http://sduzhang.cn/categories/工具包/"}],"tags":[]},{"title":"c++对象指针修改错误","slug":"对象指针修改错误","date":"2019-11-08T13:36:40.000Z","updated":"2019-12-03T04:17:11.267Z","comments":true,"path":"2019/11/08/对象指针修改错误/","link":"","permalink":"http://sduzhang.cn/2019/11/08/对象指针修改错误/","excerpt":"","text":"好久没更新了，啥也没写的几个月主要在忙学院足球队的事，发生了很多事情，我自己也受伤了。不过我最近还是很快乐——因为我发现写编译原理实验很有意思。有一说一，编译原理真的很有意思，建议所有计软方向的同学都来学习（滑稽）。快到编译原理实验截止日期了，于是最近这两天在写实验，实验的内容是写一个PL(0)文法的编译器，好像扯远了… 这次的主题是记录我在编写c++程序时一个致命错误，首先上省略后的伪代码。 1234567production *p[10];queue.in(p[0]);//p[0]入队列while (!queue.empty()) &#123; production *p1 = queue.out();//队列头出队列，第一次进入while循环时出队列的是p[0] change(p1);//对p1指向的对象进行修改 if(p1 in p) queue.in(p1);//如果p1是p中的元素，p1入队列&#125; emmm这么省略后再看觉得自己能犯这样的错误简直太傻了。由于我以为修改了p1，实际上p1和p中某一个元素指向的是同一个对象，所以总有p1 in p，循环是个死循环。所以说当使用指针的时候一定要注意，如果你的语义需要修改指针指向的对象，一定要搞清楚指针和哪些标识符指向同一个对象，保险起见在修改时应该创建一个新的对象（除非就是要修改这个对象），使用指针的时候一定要注意！！！ 否则下一次就是你要面对着几百行代码和有限的输出内容debug了（笑）。","categories":[{"name":"工具包","slug":"工具包","permalink":"http://sduzhang.cn/categories/工具包/"}],"tags":[]},{"title":"常用网站","slug":"常用网站","date":"2019-09-04T14:41:10.000Z","updated":"2019-12-03T04:17:06.516Z","comments":true,"path":"2019/09/04/常用网站/","link":"","permalink":"http://sduzhang.cn/2019/09/04/常用网站/","excerpt":"","text":"Chrome主题网站：ThemeBeta 语言练手刷题网站：LeetCode 谷歌学术 WPS Office 2019 For Linux 会议期刊查询网站： 会伴 机器学习入门笔记","categories":[{"name":"工具包","slug":"工具包","permalink":"http://sduzhang.cn/categories/工具包/"}],"tags":[]},{"title":"一种对GPU上AES加密的时序攻击","slug":"cachelinecnt-timing-attack","date":"2019-08-05T10:57:47.000Z","updated":"2019-11-08T14:03:29.534Z","comments":true,"path":"2019/08/05/cachelinecnt-timing-attack/","link":"","permalink":"http://sduzhang.cn/2019/08/05/cachelinecnt-timing-attack/","excerpt":"","text":"最近几天读了论文 A Complete Key Recovery Timing Attack on a GPU(2016 HPCA)，然后打算和学长一起复现一下这篇论文提出的攻击方法。 论文源地址 论文针对GPU上的AES实现，提出了一种攻击方式。 首先，他们的motivation是下图中加密时间和程序Cache Line请求数之间对应的线性关系。 攻击过程如下：（1）获得设备加密的大量的AES密文和对应加密的时间。 （2）逐字节对密钥进行猜测，通过密文计算所猜密钥得到理论上最后一轮加密访问的cache_line数，即下图算法三。 （3）将得到的cachelinecnt数与对应的加密时间作为两个变量，计算皮尔逊相关系数，相关性最高的猜测字节即为原始密钥的对应字节。下图为论文中所得到的结果，横坐标为猜测的密钥，纵坐标为对应皮尔逊系数，图中的尖峰即为攻击结果，k0-k15为密钥对应字节的编号。 复现代码：首先是将文件中的密文读入，并处理成二维数组，方便后续处理。 由于密文数据是将一个字节拆成两个十六进制的数字，并且转成按照对应值的字符而不是对应二进制分别存入两个字节（如密文0x4c，拆成4、c并转换成字符&#39;4&#39;和&#39;c&#39;分别存储），所以这一步略显麻烦。 1234567891011121314151617181920// init the matrix cipher[][]void preCipher(char *path) &#123; FILE *fp = fopen(path, \"r\"); char line[49]; for(int i = 0; i &lt; blockNum; i++) &#123; for(int j = 0; j &lt; 16; j++) &#123; fscanf(fp, \"%s\", line); uint8_t a,b; if (line[0] &gt;= 'a' &amp;&amp; line[0] &lt;= 'f') a = line[0] - 'a' + 9; else a = line[0] - '0'; if (line[1] &gt;= 'a' &amp;&amp; line[1] &lt;= 'f') b = line[0] - 'a' + 9; else b = line[1] - '0'; a &amp;= 0b00001111; b &amp;= 0b00001111; a = a &lt;&lt; 4; cipher[i][j] = a ^ b; &#125; &#125; fclose(fp);&#125; 然后就是最核心的cache_line_cnt的计算： 123456789101112131415//calculate the cache_line_cntint find_cnt(uint8_t kj, int j)&#123; int cache_line_cnt = 0; for (int i = 0; i &lt; 16; i++) holder[i] = 0; for (int i = 0; i &lt; blockNum; i++) &#123; uint8_t index = (Td4[cipher[i][j] ^ kj] &gt;&gt; 4) &amp; 0b00001111; ++holder[index]; // printf(\"%u %u %u\\n\", b, a,cipher[i][j]); &#125; for(int i = 0; i&lt; 16; i++) &#123; if(holder[i]) ++cache_line_cnt; &#125; return cache_line_cnt;&#125; 这里的Td4就是AES加密中的T4表。关于T4表，这篇知乎文章写的很清楚，这里不再多解释了。 在外层用多重循环去调用就能得到所需要的值。 然后再与对应时间做皮尔逊系数的计算就能得到所猜字节与对应密钥字节的相关性，这里我们使用的是python对应的库传入参数进行计算。 原论文中的攻击使用100万个样本（时间+密文），论文给出的样本数量与成功率的关系如下图。 我们首先指定样本数量为10,000，但是效果并不好，所以把样本数量改为500,000，写好脚本后等待步骤（1）中样本的生成… 结果：结果是复现没有成功，没有得到论文中那么好的数据，我们甚至没有得到一组的正确结果，不过通过复现论文中的方法，我们对时序攻击有一点点了解了，聊以自慰。 后来实验室就放暑假了（滑稽）。","categories":[{"name":"论文学习","slug":"论文学习","permalink":"http://sduzhang.cn/categories/论文学习/"}],"tags":[]},{"title":"Error: Permission denied (publickey)","slug":"Error-Permission-denied-publickey","date":"2019-07-27T03:08:21.000Z","updated":"2019-12-03T04:17:24.574Z","comments":true,"path":"2019/07/27/Error-Permission-denied-publickey/","link":"","permalink":"http://sduzhang.cn/2019/07/27/Error-Permission-denied-publickey/","excerpt":"","text":"这个问题是ssh密钥没有配置好，客户端的私钥和服务器上的公钥不对应。 在使用hexo d命令时，命令行报错Error: Permission denied (publickey)，我很确定公钥已经正确放在github上，纠结了好久不知道是哪里出了问题。 今天我在github help上找到了这个问题的解释，官方文档上提示，如果没有使用 sudo 命令生成密钥，然后尝试sudo git push，此时使用的秘钥不是你想要使用的密钥，而应该是你用sudo命令生成的密钥。 我突然发现自己经常习惯使用sudo命令对文件进行各种操作，权限不够时直接将文件修改为777，导致很多文件的权限是混乱的。对于权限这方面的理解一塌糊涂，自己还是对Linux一无所知啊… 今天又花了一上午的时间将项目重新移植，幸好项目文件不大，要不然真的要吐血了。","categories":[{"name":"工具包","slug":"工具包","permalink":"http://sduzhang.cn/categories/工具包/"}],"tags":[]},{"title":"对抗环境下深度学习的局限性","slug":"AttackOnDL","date":"2019-07-16T03:21:09.000Z","updated":"2019-08-06T07:45:44.700Z","comments":true,"path":"2019/07/16/AttackOnDL/","link":"","permalink":"http://sduzhang.cn/2019/07/16/AttackOnDL/","excerpt":"","text":"论文 The Limitations of Deep Learning in Adversarial Settings论文源地址 这是一篇16年发表在S&amp;P上的论文，引用数很多，研究者通过引入很小的扰动，使前馈神经网络对图片误分类。 论文的前提为知道神经网络的结构和权重 从第一层隐藏层开始，一层一层计算训练的函数得到整个网络的前向导数 生成对抗显著图，得到图像中点对不同分类预测的影响 使用启发式算法，选取影响最大的点进行更新 不断重复这个过程，直到成功误分类或者达到能够忍受的最大失真率。 针对MNIST这个问题，研究者每次对一对点进行更新，因为这样的点能够互相弥补不足（单个点在增加想要得到的类的概率时，也可能增加其他类的概率），并且一对点要比单个点更容易满足条件（对单个点太严格）。但是这样做复杂度提升了（要遍历所有组合而不只是点）。 对于实验的结果，研究者统计了不同类数字之间的转化率，以及不同书记之间成功样本的平均失真率，统计出了失败样例和高比例失真样例的分布，进一步追踪高比例失真样例的变化过程，发现样例离开源类别需要的失真率很高，而到达新类需要的失真率类似，所以总失真率要高（两个过程都高）。原因为DNN对一些类的识别更自信。 更进一步，研究者定义了Hardness measure来度量从原类别到目标类的难易程度，Adversarial distance来定义样本X到目标类的对抗距离，同时用大量样本对抗距离的最小值（作者指出最小值也可以用其他操作，例如统计期望来代替）来衡量一个网络的鲁棒性，并且都给出了计算的数学公式。 另外，作者在亚马逊众包网站做了统计，发现生成的对抗样本被识别的概率与原样本集相差不大，也就是说人基本上可以正确识别对抗样本。","categories":[{"name":"论文学习","slug":"论文学习","permalink":"http://sduzhang.cn/categories/论文学习/"}],"tags":[]},{"title":"对基于HPC数据进行分析的HMD的攻击","slug":"a164-Dinakarrao","date":"2019-07-11T10:55:27.000Z","updated":"2019-08-07T01:44:55.345Z","comments":true,"path":"2019/07/11/a164-Dinakarrao/","link":"","permalink":"http://sduzhang.cn/2019/07/11/a164-Dinakarrao/","excerpt":"","text":"写在前面由于需要确定研究的课题，我从DAC19的论文中按照关键词索引找到了这篇论文，并开始了对这篇论文的学习。 在学习过程中，学长觉得我做的事太庞大了，他觉得翻译全文是一件不必要的事情，同时我也意识到了这件事相当费时间，于是我决定暂停这项工作。两次翻译结果都是半途而废，但是翻译的过程却让我的思路得到了开拓，获得了知识也有了继续下去的热情和动力。 我认为在学习过程中学习方法是件很重要的事，及时吸取经验教训是一件很重要的事，接下来我会学习对论文进行重点的摘要，重点关注它的研究对象、过程、成果以及思考是否能以此为一个切入点确定题目。 读完了论文回来对论文的内容做一下总结，填一下坑。 时间： 2019-07-13 论文摘要：对（基于HPC捕获的数据进行分析的HMD）的攻击 首先对要攻击的HMD逆向，模仿得到一个白盒的HMD（文中使用ML分类器进行模仿）。 然后使用敌对样本预测器来生成所需的（能使应用被误分类的HPC数据）。 最后用敌对样本生成器作为应用的一个独立线程产生HPC数据，从HPC来看该数据也是应用的数据，总的数据会误导HMD使其将应用误分类。 （实验中，HPC所捕获的总的数据与第二步预测的数据之间的误差 &lt; 3%） 该论文中的逆向模仿的是基于ML分类器的HMD，同时论文用实验的方式验证对基于LR（Logistic Regression）的HMD也同样有效，进一步提出只要能够逆向HMD，论文提出的方法都有效。 下面是论文的摘要 。 Adversarial Attack on Microarchitectural Events based Malware Detectors（对基于恶意软件检测器的微结构事件的对抗性攻击）论文来源：DAC 19论文地址Abstract为了克服传统的基于软件的恶意软件检测技术导致的性能开销，使用机器学习分类器的硬件辅助恶意软件检测（Hardware-assisted Malware Detection，HMD）已经作为一种灵丹妙药出现来检测恶意应用、保护系统。HMD主要依靠通过硬件性能计数器（Hardware Performance Counters，HPCs）捕获生成的底层微结构事件，来区分良性软件和恶意软件。这个工作创建了一个对HMD系统的对抗性攻击，通过一个对抗性样例生成器应用在HPC跟踪（trace）中引入这种微扰来干预（tamper）系统的安全性。为了精巧地制作攻击，我们首先部署了一个对抗性样本预测器，预测对于给定应用程序在HMD被部署的机器学习（ML）分类器错误分类时的敌对HPC模式。进一步，由于攻击者没有直接访问在运行时生成的HPC的权限，因此我们基于对抗样本检测器的输出设计了一种包装在正常应用周围的对抗性样本生成器，用它来生成类似对抗检测器跟踪（trace）的HPC模式。由于对抗性样本生成器应用没有任何的恶意操作，它在传统的基于签名的恶意软件检测措施中无法被检测。用这种攻击方式，恶意软件检测率从82.76%降低到了18.04%。","categories":[{"name":"论文学习","slug":"论文学习","permalink":"http://sduzhang.cn/categories/论文学习/"}],"tags":[]},{"title":"MalGAN","slug":"MalGAN","date":"2019-07-10T02:48:33.000Z","updated":"2019-08-06T07:51:45.775Z","comments":true,"path":"2019/07/10/MalGAN/","link":"","permalink":"http://sduzhang.cn/2019/07/10/MalGAN/","excerpt":"","text":"写在前面今天开始进行人工智能安全方面的学习，首先是找了白皮书来看，在白皮书里提到了这篇论文，于是在这里对这篇论文进行翻译，通过这种方式对论文进行阅读和理解。 由于要开始找题做项目，所以这篇的翻译就到此为止，这篇半成品也算是给自己留作纪念，虽然翻译的过程费了时间，不过也不是没有收获，尽管翻得不好，但是在这个过程中对一些知识有了最基本的认识，借机看了GAN，感觉还是对自己比较满意的。 尽管我没翻完，但是我找到了别人对这篇论文的心得 看着别人的心得，觉得自己还有很长的路要走啊。 以下是原文的摘要。 论文名称：Generating Adversarial Malware Examples for Black-Box Attacks Based on GAN（基于GAN的黑盒测试敌对恶意软件样本生成）论文源地址 Abstact最近几年，机器学习已经被用作检测新型的恶意代码（malware），而恶意代码的作者有着强烈的积极性去攻击这些算法。恶意代码的作者通常没有机会了解恶意代码检测系统中使用的机器学习模型的详细结构和参数，因此他们只能进行黑盒攻击。这篇论文提出了一个生成对抗网络（Generative Adversarial Network），这个网络基于MalGAN算法生成的、可能会绕过黑盒恶意代码检测系统的恶意对抗代码样例。MalGAN使用一个替代检测器（substitute detector）去匹配（fit）黑盒恶意代码检测系统。一个生成网络被训练成最小化替代检测器预测的生成对抗样本的恶意率。MalGAN相对传统基于对抗样本生成算法的有事是MalGAN能使预测率降低到几乎为零，并且能使基于再训练的对抗样本的防御方法难以工作。 剩下内容简单概述可以看这个博客。","categories":[{"name":"论文学习","slug":"论文学习","permalink":"http://sduzhang.cn/categories/论文学习/"}],"tags":[]}]}