{"meta":{"title":"Zyh's site","subtitle":"这里是Zyh的博客","description":null,"author":"Zyh","url":"http://sduzhang.cn","root":"/"},"pages":[{"title":"关于","date":"2019-07-27T02:36:02.000Z","updated":"2019-07-29T01:31:57.803Z","comments":true,"path":"about/index.html","permalink":"http://sduzhang.cn/about/index.html","excerpt":"","text":"Welcome经过一天的折腾终于有了一个自己的博客 工具是 hexo + github page 一日速成主要是靠这个博客 这个博客是用来记录我的学习过程中和自己对一些事情的见解，感兴趣的话可以关注我或者联系我。"},{"title":"categories","date":"2019-07-27T02:32:40.000Z","updated":"2019-07-27T02:34:17.890Z","comments":false,"path":"categories/index.html","permalink":"http://sduzhang.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-27T02:34:42.000Z","updated":"2019-07-27T02:35:25.214Z","comments":false,"path":"tags/index.html","permalink":"http://sduzhang.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"复现AES时序攻击","slug":"cachelinecnt-timing-attack","date":"2019-08-05T10:57:47.000Z","updated":"2019-08-06T02:10:40.890Z","comments":true,"path":"2019/08/05/cachelinecnt-timing-attack/","link":"","permalink":"http://sduzhang.cn/2019/08/05/cachelinecnt-timing-attack/","excerpt":"","text":"最近几天读了论文 A Complete Key Recovery Timing Attack on a GPU(2016 HPCA)，然后打算和学长一起复现一下这篇论文提出的攻击方法。 论文源地址 论文针对GPU上的AES实现，提出了一种攻击方式。 首先，他们的motivation是下图中加密时间和程序Cache Line请求数之间对应的线性关系。 {: width=”250px” height=”250px”} 攻击过程如下：（1）获得设备加密的大量的AES密文和对应加密的时间。 （2）逐字节对密钥进行猜测，通过密文计算所猜密钥得到理论上最后一轮加密访问的cache_line数，即下图算法三。 {: height=”250px”} （3）将得到的cachelinecnt数与对应的加密时间作为两个变量，计算皮尔逊相关系数，相关性最高的猜测字节即为原始密钥的对应字节。下图为论文中所得到的结果，横坐标为猜测的密钥，纵坐标为对应皮尔逊系数，图中的尖峰即为攻击结果，k0-k15为密钥对应字节的编号。 {: height=”250px”} 复现代码：首先是将文件中的密文读入，并处理成二维数组，方便后续处理。 由于密文数据是将一个字节拆成两个十六进制的数字，并且转成按照对应值的字符而不是对应二进制分别存入两个字节（如密文0x4c，拆成4、c并转换成字符&#39;4&#39;和&#39;c&#39;分别存储），所以这一步略显麻烦。 1234567891011121314151617181920// init the matrix cipher[][]void preCipher(char *path) &#123; FILE *fp = fopen(path, \"r\"); char line[49]; for(int i = 0; i &lt; blockNum; i++) &#123; for(int j = 0; j &lt; 16; j++) &#123; fscanf(fp, \"%s\", line); uint8_t a,b; if (line[0] &gt;= 'a' &amp;&amp; line[0] &lt;= 'f') a = line[0] - 'a' + 9; else a = line[0] - '0'; if (line[1] &gt;= 'a' &amp;&amp; line[1] &lt;= 'f') b = line[0] - 'a' + 9; else b = line[1] - '0'; a &amp;= 0b00001111; b &amp;= 0b00001111; a = a &lt;&lt; 4; cipher[i][j] = a ^ b; &#125; &#125; fclose(fp);&#125; 然后就是最核心的cache_line_cnt的计算： 123456789101112131415//calculate the cache_line_cntint find_cnt(uint8_t kj, int j)&#123; int cache_line_cnt = 0; for (int i = 0; i &lt; 16; i++) holder[i] = 0; for (int i = 0; i &lt; blockNum; i++) &#123; uint8_t index = (Td4[cipher[i][j] ^ kj] &gt;&gt; 4) &amp; 0b00001111; ++holder[index]; // printf(\"%u %u %u\\n\", b, a,cipher[i][j]); &#125; for(int i = 0; i&lt; 16; i++) &#123; if(holder[i]) ++cache_line_cnt; &#125; return cache_line_cnt;&#125; 这里的Td4就是AES加密中的T4表。关于T4表，这篇知乎文章写的很清楚，这里不再多解释了。 在外层用多重循环去调用就能得到所需要的值。 然后再与对应时间做皮尔逊系数的计算就能得到所猜字节与对应密钥字节的相关性。 原论文中的攻击使用100万个样本（时间+密文），论文给出的样本数量与成功率的关系如下图。 {: height=”200px”} 我们首先指定样本数量为10,000，但是效果并不好，所以把样本数量改为500,000，写好脚本后就是漫长的等待过程了… 结果：","categories":[{"name":"论文学习","slug":"论文学习","permalink":"http://sduzhang.cn/categories/论文学习/"}],"tags":[]},{"title":"Error: Permission denied (publickey)","slug":"Error-Permission-denied-publickey","date":"2019-07-27T03:08:21.000Z","updated":"2019-07-29T01:28:31.852Z","comments":true,"path":"2019/07/27/Error-Permission-denied-publickey/","link":"","permalink":"http://sduzhang.cn/2019/07/27/Error-Permission-denied-publickey/","excerpt":"","text":"这个问题是ssh密钥没有配置好，客户端的私钥和服务器上的公钥不对应。 在使用hexo d命令时，命令行报错Error: Permission denied (publickey)，我很确定公钥已经正确放在github上，纠结了好久不知道是哪里出了问题。 今天我在github help上找到了这个问题的解释，官方文档上提示，如果没有使用 sudo 命令生成密钥，然后尝试sudo git push，此时使用的秘钥不是你想要使用的密钥，而应该是你用sudo命令生成的密钥。 我突然发现自己经常习惯使用sudo命令对文件进行各种操作，权限不够时直接将文件修改为777，导致很多文件的权限是混乱的。对于权限这方面的理解一塌糊涂，自己还是对Linux一无所知啊… 今天又花了一上午的时间将项目重新移植，幸好项目文件不大，要不然真的要吐血了。","categories":[{"name":"技术","slug":"技术","permalink":"http://sduzhang.cn/categories/技术/"}],"tags":[]},{"title":"对抗环境下深度学习的局限性","slug":"AttackOnDL","date":"2019-07-16T03:21:09.000Z","updated":"2019-07-27T02:39:40.780Z","comments":true,"path":"2019/07/16/AttackOnDL/","link":"","permalink":"http://sduzhang.cn/2019/07/16/AttackOnDL/","excerpt":"","text":"论文 The Limitations of Deep Learning in Adversarial Settings论文源地址 这是一篇16年发表在S&amp;P上的论文，引用数很多，研究者通过引入很小的扰动，使前馈神经网络对图片误分类。 论文的前提为知道神经网络的结构和权重 从第一层隐藏层开始，一层一层计算训练的函数得到整个网络的前向导数 生成对抗显著图，得到图像中点对不同分类预测的影响 使用启发式算法，选取影响最大的点进行更新 不断重复这个过程，直到成功误分类或者达到能够忍受的最大失真率。 针对MNIST这个问题，研究者每次对一对点进行更新，因为这样的点能够互相弥补不足（单个点在增加想要得到的类的概率时，也可能增加其他类的概率），并且一对点要比单个点更容易满足条件（对单个点太严格）。但是这样做复杂度提升了（要遍历所有组合而不只是点）。 对于实验的结果，研究者统计了不同类数字之间的转化率，以及不同书记之间成功样本的平均失真率，统计出了失败样例和高比例失真样例的分布，进一步追踪高比例失真样例的变化过程，发现样例离开源类别需要的失真率很高，而到达新类需要的失真率类似，所以总失真率要高（两个过程都高）。原因为DNN对一些类的识别更自信。 更进一步，研究者定义了Hardness measure来度量从原类别到目标类的难易程度，Adversarial distance来定义样本X到目标类的对抗距离，同时用大量样本对抗距离的最小值（作者指出最小值也可以用其他操作，例如统计期望来代替）来衡量一个网络的鲁棒性，并且都给出了计算的数学公式。 另外，作者在亚马逊众包网站做了统计，发现生成的对抗样本被识别的概率与原样本集相差不大，也就是说人基本上可以正确识别对抗样本。","categories":[{"name":"论文学习","slug":"论文学习","permalink":"http://sduzhang.cn/categories/论文学习/"}],"tags":[]},{"title":"对基于HPC数据进行分析的HMD的攻击","slug":"a164-Dinakarrao","date":"2019-07-11T10:55:27.000Z","updated":"2019-07-27T02:40:53.948Z","comments":true,"path":"2019/07/11/a164-Dinakarrao/","link":"","permalink":"http://sduzhang.cn/2019/07/11/a164-Dinakarrao/","excerpt":"","text":"写在前面由于需要确定研究的课题，我从DAC19的论文中按照关键词索引找到了这篇论文，并开始了对这篇论文的学习。 在学习过程中，学长觉得我做的事太庞大了，他觉得翻译全文是一件不必要的事情，同时我也意识到了这件事相当费时间，于是我决定暂停这项工作。两次翻译结果都是半途而废，但是翻译的过程却让我的思路得到了开拓，获得了知识也有了继续下去的热情和动力。 我认为在学习过程中学习方法是件很重要的事，及时吸取经验教训是一件很重要的事，接下来我会学习对论文进行重点的摘要，重点关注它的研究对象、过程、成果以及思考是否能以此为一个切入点确定题目。 读完了论文回来对论文的内容做一下总结，填一下坑。 时间： 2019-07-13 论文摘要：对（基于HPC捕获的数据进行分析的HMD）的攻击 首先对要攻击的HMD逆向，模仿得到一个白盒的HMD（文中使用ML分类器进行模仿）。 然后使用敌对样本预测器来生成所需的（能使应用被误分类的HPC数据）。 最后用敌对样本生成器作为应用的一个独立线程产生HPC数据，从HPC来看该数据也是应用的数据，总的数据会误导HMD使其将应用误分类。 （实验中，HPC所捕获的总的数据与第二步预测的数据之间的误差 &lt; 3%） 该论文中的逆向模仿的是基于ML分类器的HMD，同时论文用实验的方式验证对基于LR的HMD也同样有效，进一步提出只要能够逆向HMD，论文提出的方法都有效。 下面是论文前几段的详细内容 。 Adversarial Attack on Microarchitectural Events based Malware Detectors（对基于恶意软件检测器的微结构事件的对抗性攻击）论文来源：DAC 19论文地址Abstract为了克服传统的基于软件的恶意软件检测技术导致的性能开销，使用机器学习分类器的硬件辅助恶意软件检测（Hardware-assisted Malware Detection，HMD）已经作为一种灵丹妙药出现来检测恶意应用、保护系统。HMD主要依靠通过硬件性能计数器（Hardware Performance Counters，HPCs）捕获生成的底层微结构事件，来区分良性软件和恶意软件。这个工作创建了一个对HMD系统的对抗性攻击，通过一个对抗性样例生成器应用在HPC跟踪（trace）中引入这种微扰来干预（tamper）系统的安全性。为了精巧地制作攻击，我们首先部署了一个对抗性样本预测器，预测对于给定应用程序在HMD被部署的机器学习（ML）分类器错误分类时的敌对HPC模式。进一步，由于攻击者没有直接访问在运行时生成的HPC的权限，因此我们基于对抗样本检测器的输出设计了一种包装在正常应用周围的对抗性样本生成器，用它来生成类似对抗检测器跟踪（trace）的HPC模式。由于对抗性样本生成器应用没有任何的恶意操作，它在传统的基于签名的恶意软件检测措施中无法被检测。用这种攻击方式，恶意软件检测率从82.76%降低到了18.04%。 Keywords恶意软件检测，对抗性学习，对抗性恶意软件，硬件安全，硬件辅助安全，机器学习 ACM Reference Format:Sai Manoj Pudukotai Dinakarrao, Sairaj Amberkar, Sahil Bhat, Abhijitt Dhavlle, Hossein Sayadi, Avesta Sasan, Houman Homayoun and Setareh Rafatirad. 2019. Adversarial Attack on Microarchitectural Events based Malware Detectors . In The 56th Annual Design Automation Conference 2019 (DAC ’19), June 2–6, 2019, Las Vegas, NV, USA. ACM, New York, NY, USA, 6 pages. https://doi.org/10.1145/3316781.3317762 1 Introduction现代计算机系统日益增加的复杂性导致了安全漏洞的增加，使这些系统成为复杂攻击的目标。攻击者利用存在的破坏系统的漏洞并部署恶意软件。Malware，也被称为恶意软件，是一个被攻击者设计用来在没有得到用户许可的情况下，为了有害的目的去感染计算机系统的程序或应用，例如窃取敏感信息，访问未经授权的数据，破坏文件，在设备上运行侵入性的程序来执行DoS（Denial-of-Service）攻击，中断必要服务来进行金融诈骗（financial fraud）。 为了克服传统签名和基于语义的软件驱动的恶意软件检测技术 [11,19] 的开销和计算复杂度等缺点，HMD方法被 [5] 提出。HMD利用底层的微结构硬件事件和日志来检测和区分恶意软件。它的好处是用更小的硬件成本 [5] 降低了恶意软件检测延迟的数量级。最近的工作 [4-6, 20-22, 24, 25] 已经展现出，通过部署机器学习技术，利用HPCs捕获的底层微结构事件（特征），可以帮助区分良性和恶意软件。HPCs是一组内置在现代微处理器中的特殊用途寄存器，用于捕获硬件相关事件的追踪，例如LLC加载失败（miss）、分支指令、分支失败（miss）和执行应用程序（良性或恶意）时执行的指令。 [5] 的工作是提出利用HPC数据进行恶意软件检测的前期工作之一，证明了离线ML算法在恶意软件分类中的有效性。采用多种ML算法（ANN， KNN）对安卓恶意软件进行检测，结果显示出了高检测精度。在 [7] 和 [24] 中的研究者讨论了通过在硬件性能计数器的信息中发现异常，在底层特征上采用无人管理的学习方法，来检测面向返回编程（ROP）和缓冲区溢出攻击的可行性。尽管无人管理的算法在检测心得恶意软件和攻击者进化方面更有效，但它们本质上是复杂的，需要更复杂的分析和计算开销。[15] 中的工作使用了逻辑回归把恶意软件分成多个类，并且训练了一个专门的分类器来检测恶意软件类。他们进一步使用专用集成学习来提高逻辑回归的准确性。为了增强性能，[15, 21] 中的工作提出了使用基于集成ML的解决方案，使用底层微处理器特性有效地检测恶意软件。这些基于ML的恶意软件检测器能在微处理器中实现，并且和软件基础的方法相比能显著降低开销，因为在硬件内部检测的速度非常快（几个时钟周期）[19, 25]。作为一个整体，可以看出最近大量的工作一直致力于采集底层微处理器事件给ML分类来保证（make）系统安全。 另一方面，尽管ML分类器被部署在许多应用并且展现了对抗随机噪声的鲁棒性，暴露的漏洞还是表明，能通过在输入数据中添加特制的干扰修改或控制 ML分类器[8, 17, 18, 23]，这种数据通常称为敌对样本（Adversarial samples）。目前存在大量关于敌对攻击的研究，主要集中在具体的计算机视觉应用上 [8, 17, 18, 23]，其中特征的数量通常很大。……","categories":[{"name":"论文学习","slug":"论文学习","permalink":"http://sduzhang.cn/categories/论文学习/"}],"tags":[]},{"title":"MalGAN","slug":"MalGAN","date":"2019-07-10T02:48:33.000Z","updated":"2019-07-27T02:38:41.993Z","comments":true,"path":"2019/07/10/MalGAN/","link":"","permalink":"http://sduzhang.cn/2019/07/10/MalGAN/","excerpt":"","text":"写在前面今天开始进行人工智能安全方面的学习，首先是找了白皮书来看，在白皮书里提到了这篇论文，于是在这里对这篇论文进行翻译，通过这种方式对论文进行阅读和理解。 由于要开始找题做项目，所以这篇的翻译就到此为止，这篇半成品也算是给自己留作纪念，虽然翻译的过程费了时间，不过也不是没有收获，尽管翻得不好，但是在这个过程中对一些知识有了最基本的认识，借机看了GAN，感觉还是对自己比较满意的。 尽管我没翻完，但是我找到了别人看完了这篇论文之后的心得 看着别人的心得，觉得自己还有很长的路要走啊。 以下是原文的前一小部分的翻译。 论文名称：Generating Adversarial Malware Examples for Black-Box Attacks Based on GAN（基于GAN的黑盒测试敌对恶意软件样本生成）来源：北京大学Abstact最近几年，机器学习已经被用作检测新型的恶意代码（malware），而恶意代码的作者有着强烈的积极性去攻击这些算法。恶意代码的作者通常没有机会了解恶意代码检测系统中使用的机器学习模型的详细结构和参数，因此他们只能进行黑盒攻击。这篇论文提出了一个生成对抗网络（Generative Adversarial Network），这个网络基于MalGAN算法生成的、可能会绕过黑盒恶意代码检测系统的恶意对抗代码样例。MalGAN使用一个替代检测器（substitute detector）去匹配（fit）黑盒恶意代码检测系统。一个生成网络被训练成最小化替代检测器预测的生成对抗样本的恶意率。MalGAN相对传统基于对抗样本生成算法的有事是MalGAN能使预测率降低到几乎为零，并且能使基于再训练的对抗样本的防御方法难以工作。 1 Introduction近年来，许多基于机器学习的算法已经被提出要进行恶意代码的检测，这些检测从程序中提取特征，使用一种分类器在良性程序和恶意程序间进行分类。例如…… 大多数研究者把他们的努力聚焦在提高算法的检测结果（performance），但却忽视了算法的鲁棒性。通常来说，恶意软件的传播能使作者受益，因此，恶意软件的作者有足够的动力来对检测算法进行攻击。 许多机器学习的算法在面对恶意攻击时非常脆弱……（未翻完） 剩下内容简单概述可以看这个博客。 论文的源地址。","categories":[{"name":"论文学习","slug":"论文学习","permalink":"http://sduzhang.cn/categories/论文学习/"}],"tags":[]}]}